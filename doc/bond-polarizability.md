# `bond-polarizability` script

`bond-polarizability` is an attempt to factor out a separate binary for just the part that applies the bond polarizability model to compute mode raman intensities.  It can be built using fewer dependencies than the other binaries in rsp2.

## Building and running

Run `scripts/bond-polarizability`.  If the binary hasn't been built yet, this will build it automatically.  (if you get an error about no binary named `cargo`, rust is not installed)

Two input files are required:

* **The structure**, in VASP POSCAR format.  (units: Angstrom)
* **The dynamical matrix at gamma**, in a `.json` or `.json.gz` file whose format is described in the next section.  Notice that `.npz`-format files such as those normally generated by rsp2 are NOT supported by this binary.  (units: ev/(Angstrom^2 amu))

```sh
RSP2=/path/to/rsp2

$RSP2/scripts/bond-polarizability  structure.vasp  --dynmat gamma-dynmat.json.gz  --output raman.json
```

You can use `--temperature TEMP` (default: 0, units: K) to control the occupation of phonon states.  There is no option for setting light-frequency, because in the bond polarizability model, the frequency of light merely introduces a uniform prefactor.

### Preparing a dynamical matrix JSON file

rsp2 normally likes to store dynamical matrices as sparse BSR matrices in `.npz` format.  If you have one of these files, a python script exists to convert it into the `.json.gz` format.

```
RSP2=/path/to/rsp2
export PYTHONPATH=$RSP2/src/python:$PYTHONPATH

python3 -m rsp2.cli.convert_dynmat gamma-dynmat.npz -o dynmat.json.gz
```

If you don't have of these files, but you have a dynamical matrix, you can create one from python, using `scipy.sparse.save_npz` to save a [`scipy.sparse.bsr_matrix`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.html) with 3x3 blocks and either a `np.float64` or `np.complex128` datatype.

If you are not working in python, but are able to generate JSON, then here is what the JSON is expected to contain.  This is essentially a BSR format:

```
{
  "dim": [<natom>, <natom>],
  "col": <col_index>,
  "row": <row_ptr>,
  "complex-blocks": [
    [<block_0_real>, <block_0_imag>],
    [<block_1_real>, <block_1_imag>],
    ...
  ] 
}
```

The `complex-blocks`, `col_index` and `row_ptr` arrays correspond to `data`, `indices` and `indptr` respectively in [scipy's documentation of `bsr_matrix`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.bsr_matrix.html).  `dim` is also like `shape`, except that `dim` should not include factors of 3 (which is why `<natoms>` has been written above).

Each item of `complex-blocks` is a tuple of two 3x3 matrices; the first is the real part of that submatrix, the second is the imaginary part.  The imaginary parts should always be `[[0, 0, 0], [0, 0, 0], [0, 0, 0]]`, since the bond polarizability model is only valid at gamma.

### Output

The output is JSON and looks like the following:

```
{
  "frequencies": <frequencies>,
  "raman_tensors": <raman_tensors>,
  "raman_intensity_prefactors": <prefactors>,
  "temperatures": <temperatures>,
}
```

`<frequencies>` gives the frequencies of each mode (using negative numbers for imaginary frequencies), in cm^-1.

`<raman_tensors>` is an array of 3x3 raman tensors for each mode.  These are each the derivatives of the polarizability with respect to a normal coordinate.  The units are arbitrary.

`<temperatures>` are the temperatures at which intensity prefactors were evaluated.

`<prefactors>` is a 2D array indexed by temperature and eigenvector.  This contains `bose_occupation / mode_frequency`.

**The raman intensity of the `w`-th mode at the `T`-th temperature is `abs(in_pol * tensor[w] * out_pol)^2 * prefactor[T][w]` (where `in_pol` and `out_pol` are unit vectors indicating polarization).**  The units of this are arbitrary and lack some uniform prefactors (in particular, dependence on light frequency).

Please be aware that not all eigensolver codes produce the same result, so the modes listed in the output **might not be in direct 1-1 correspondence with modes you have computed through different means**, especially for degenerate or nearly-degenerate subspaces.

## Wishlist features

Things you cannot currently do, but may be able to in the future:

* Ability to supply multiple temperatures, to get data for each temperature without repeating the expensive matrix diagonalization.
* Ability to directly supply eigenmodes. (allowing diagonalization to be avoided, and also allowing the computation to run on fewer than all 3N modes)
* Ability to override the default masses of each element.  (in case your dynamical matrix was generated using different masses)
